# ============================================
# Docker Compose 主配置文件
# 多 Dockerfile 实战案例
# ============================================

# 注意：version 字段在新版本中已弃用，但为了兼容性保留
version: '3.8'

# ==================== 服务定义 ====================
services:
  # ---------- PostgreSQL 数据库 ----------
  db:
    image: postgres:15-alpine
    container_name: myapp-postgres
    restart: unless-stopped
    
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres123}
      POSTGRES_DB: ${POSTGRES_DB:-myapp}
      PGDATA: /var/lib/postgresql/data/pgdata
    
    volumes:
      - postgres-data:/var/lib/postgresql/data
    
    ports:
      - "5432:5432"
    
    networks:
      - backend-network
    
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    
    labels:
      com.example.service: "database"
      com.example.description: "PostgreSQL database"

  # ---------- Redis 缓存 ----------
  redis:
    image: redis:7-alpine
    container_name: myapp-redis
    restart: unless-stopped
    
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD:-}
    
    volumes:
      - redis-data:/data
    
    ports:
      - "6379:6379"
    
    networks:
      - backend-network
    
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 5s
    
    labels:
      com.example.service: "cache"
      com.example.description: "Redis cache"

  # ---------- 后端 API (Flask) ----------
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
      args:
        - BUILD_DATE=${BUILD_DATE:-2024-01-01}
        - VERSION=${VERSION:-1.0}
      # 缓存优化
      cache_from:
        - myapp-backend:latest
      # 构建时标签
      labels:
        - "com.example.build=true"
    
    image: myapp-backend:latest
    container_name: myapp-backend
    restart: unless-stopped
    
    environment:
      - FLASK_ENV=${FLASK_ENV:-production}
      - DATABASE_URL=postgresql://${POSTGRES_USER:-postgres}:${POSTGRES_PASSWORD:-postgres123}@db:5432/${POSTGRES_DB:-myapp}
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - BACKEND_PORT=5000
      - SECRET_KEY=${SECRET_KEY:-change-me-in-production}
    
    # 也可以使用 env_file
    # env_file:
    #   - .env
    
    ports:
      - "5000:5000"
    
    volumes:
      # 日志持久化（可选）
      - ./logs/backend:/app/logs
    
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    
    networks:
      - backend-network
      - frontend-network
    
    # 资源限制（可选，Docker Swarm 模式下需要 deploy）
    # deploy:
    #   resources:
    #     limits:
    #       cpus: '0.5'
    #       memory: 512M
    #     reservations:
    #       cpus: '0.25'
    #       memory: 256M
    
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/api/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 40s
    
    labels:
      com.example.service: "backend"
      com.example.description: "Flask API backend"

  # ---------- 前端应用 (React + Nginx) ----------
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: production  # 多阶段构建的目标阶段
      args:
        - REACT_APP_API_URL=${REACT_APP_API_URL:-http://localhost:5000}
        - NODE_ENV=${NODE_ENV:-production}
      cache_from:
        - myapp-frontend:latest
    
    image: myapp-frontend:latest
    container_name: myapp-frontend
    restart: unless-stopped
    
    environment:
      - NGINX_PORT=80
    
    ports:
      - "3000:80"
    
    depends_on:
      - backend
    
    networks:
      - frontend-network
    
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 10s
    
    labels:
      com.example.service: "frontend"
      com.example.description: "React frontend application"

  # ---------- Nginx 反向代理 ----------
  nginx:
    build:
      context: ./nginx
      dockerfile: Dockerfile
    
    image: myapp-nginx:latest
    container_name: myapp-nginx
    restart: unless-stopped
    
    ports:
      - "${NGINX_PORT:-80}:80"
      # - "443:443"  # HTTPS（如果配置了 SSL）
    
    volumes:
      # 自定义配置（如果需要动态更新）
      # - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      # SSL 证书（如果使用 HTTPS）
      # - ./nginx/ssl:/etc/nginx/ssl:ro
      # 日志持久化
      - ./logs/nginx:/var/log/nginx
    
    depends_on:
      - frontend
      - backend
    
    networks:
      - frontend-network
    
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/nginx-health"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 5s
    
    labels:
      com.example.service: "proxy"
      com.example.description: "Nginx reverse proxy"

# ==================== 网络定义 ====================
networks:
  # 前端网络（frontend、nginx）
  frontend-network:
    driver: bridge
    labels:
      com.example.network: "frontend"
  
  # 后端网络（backend、db、redis）
  backend-network:
    driver: bridge
    labels:
      com.example.network: "backend"
    # 自定义子网（可选）
    # ipam:
    #   driver: default
    #   config:
    #     - subnet: 172.28.0.0/16

# ==================== 卷定义 ====================
volumes:
  # PostgreSQL 数据持久化
  postgres-data:
    driver: local
    labels:
      com.example.volume: "database"
  
  # Redis 数据持久化
  redis-data:
    driver: local
    labels:
      com.example.volume: "cache"
  
  # 如果使用外部卷
  # postgres-data:
  #   external: true

# ==================== 配置和密钥（Swarm 模式）====================
# configs:
#   nginx_config:
#     file: ./nginx/nginx.conf
#
# secrets:
#   db_password:
#     file: ./secrets/db_password.txt
